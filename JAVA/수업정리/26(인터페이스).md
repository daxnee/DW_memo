### 220420

### 상속을 하는 이유?
- 마라토너 패키지가 있다고 가정
    - 선수A 뛰다()
    - 선수B 뛰다()
    - 선수C 뛰다()
        
        => 상속을 이용해서 뛰다를 공통으로 처리

```java
    기능{

    뛰다()

    }

    선수A extends 기능{
    뛰다()  // <- 부모클래스에 있는 메소드임
    }

```

: 상속을 하면 부모클래스 메소드를 사용할 수 있다.

모든 클래스의 부모클래스는 Object임!

<자바 상속의 한계>

- 자바, 자바스크립트는 다중상속이 불가능!
* C++은 다중상속 허용

- 다중상속이 불가능하면 어떤 일?

    - 급여를 받는 운동선수라고 가정하면, 
'급여()' 함수를 넣어야 하지만 기능 클래스와 관계가 없어서 불가능하다.


### 다중상속 받는법! ***

- 인터페이스를 제공해줌

- 인터페이스로 마치 다중상속을 받은 것처럼 사용할 수 있다.


### 추상화 개념(추상화라는 개념을 알아야 이해가 가능!)

- 공통적으로 사용하는 기능을 따로 정의.


### 추상클래스, 메소드

    - 추상클래스는 abstract 키워드로 선언된 클래스
    - 추상클래스에는 일반메소드, 추상메소드를 정의할 수 있다.
    
    ** 추상 : 공통 기능

    - 추상메소드는 로직구현이 목적이 아님!
    - 추상클래스는 new로 인스턴스화(호출)할 수 없다.
    - 추상메소드가 있는 추상클래스를 상속 받으면 무조건 오버라이딩을 해야함.




### 추상클래스 예시
```java
 package 롱타임노씨;

abstract class Chef{ // 추상클래스
	//**추상메소드 or 일반메소드를 정의할 수 있음!
	public void 요리를하다() { //일반메소드
		
	}
	abstract public void  비법을전수하다(); {//추상메소드. 가져다 쓰는 오버라이딩이 목적
		
	}
	
	}
class Food extends Chef{
	// Food가 오버라이딩을 하면 Food클래스를 인스턴스화(== new 호출) 할 수 있다.
	@Override
	public void 비법을전수하다() {
		// TODO Auto-generated method stub
		
	}
	
}

public class 추상화를배우자 {
	public static void main(String[] args) {
		Food f = new Food();
	}
	
}
   
```

### 추상클래스의 한계
- 결국엔 클래스이기 때문에 가져다 사용해도 다중상속이 불가능!

---

### 인터페이스 
- 데이터를 제공하는 규격(공통기능을 제공하는 것. 주체)
- 인터페이스는 다중상속을 제공***
- 인터페이스를 상속받으면 무조건 오버라이딩이 필요함**
    - why? 클래스를 가져다 쓰는 것이 목적이기 때문에!
- 인터페이스 안에 있는 모든 메소드는 추상메소드다.
추상메소드는 public이어야 한다.


### 프로젝트 설계시 담당업무
- 과장1 (테이블설계, 인터페이스 설계, 클라이언트 요구사항 정리)
    - 코드 구현시, 핵심 로직만
- 대리1 (소스통합 & 배포)
- 사원1 (코드 구현)



### 인터페이스로 다중상속 해보기 (상속 : 공통기능을 정의해서 가져다가 쓰려고 사용)

```java
package 롱타임노씨;

public interface UserImple {
	void 요리를맛보다(); // public abstract 생략!
	void 요리를평가하다();
}

```


```java

package 롱타임노씨;

public class 백종원의요리교실 implements ServiceImple,  UserImple {
// 백종원의요리교실에 커서를 두면 add하라는 키가 뜬다. 클릭 
	@Override
	public void 라면끓이는방법() {
		// 여기에 로직 구현하면 된다.
		
	}

	@Override
	public void 찌개끓이는방법() {
		
	}

	@Override
	public void 요리를맛보다() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void 요리를평가하다() {
		// TODO Auto-generated method stub
		
	}
	
}
```


### 클래스를 상속(extends) / 인터페이스(implements) 상속의 차이점

- extends : 오버라이딩 선택 사항 
부모에서 선언/정의를 모두 하며 오버라이딩 할 필요 없이 부모의 메소드 변수를 그대로 사용.  *단 추상클래스라면 오버라이딩이 필수임

- implements : 오버라이딩 필수 사항.
부모 객체는 선언만 하며 정의는 자식에서 오버라이딩하여 사용함.


### 클래스를 파라미터로 받는 것: 약한 결합 (프로그래밍 언어)
ex)

public List<UserVO> updateSal(List<UserVO> list, String dname) {
		return list;
	}


약한 결합 : (Loose Coupling) => 약할수록 좋은 프로그래밍
강한 결합 : (Tight Coupling) 
: 직접 new로 호출하는 메소드


### 실무에서 사용하는 인스턴스화 방법
UserService2 클래스를 하나 더 만들었다고 가정.

  UserServiceImple service = new UserService();
        service = new UserService2();

원래는 개별로 new를 사용해서 호출해줘야 했다면
 *** 
https://wooono.tistory.com/261


### 주석달기 : 누가 어떤 메소드를 만들었는지 추척하기 세팅(세팅 기본사항) *** 

- 주석 만드는 단축키: alt + shift + j => 누가 만들었는지 설정해놓기
- 주석 확인하는 방법 : 호출한 메소드에 마우스 클릭하면 정보 확인 가능


- 만드는 방법: window ->  preferences -> Java -> Code Style -> Code Templates -> Comments -> Methods -> edit -> 

/**
 * ${tags}
 * @date : ${date} 
 * @author : yde // 내 이름으로 설정
 */


 -> Types -> edits
    *types: 클래스를 의미
/**
 * @author yde
 * @Date ${date}
 * comment :  // 어떤 메소드인지 간략하게 설명 작성하기
 */







