### 220413


### 상속

```java
class Study{ //  중복 제거하기
	public void doStudy(String subjects) {
		
	}
}


class StudentC extends Study{ // Study클래스를 상속 extends 기준으로 왼쪽(자식) 오른쪽(부모)
	
	public void doStudy() {
		System.out.println("JAVA를 공부하다.");
	}
}
```

- extends 기준으로 왼쪽은 자식 클래스 (서브클래스) 오른쪽은 부모클래스(슈퍼클래스)

### 상속을 받으면 부모클래스의 필드변수와 메소드를 사용할 수 있다. 단,   public 일때 
모든 클래스는  Object의 자식이기 때문에 
모든 클래스는  Object의 메소드를 사용할 수 있다.

--- 

### 오버로딩 vs 오버라이딩 *기술면접 빈출 질문 (객체지향 언어의 특징)

- 오버로딩 
    - 개념 : 같은 클래스 or 상속 관계에서 동일한 이름의 메소드 중복 가능
    - 조건 : 메소드 이름은 동일해야 함. 파라미터(인수,인자,매개변수) 개수, 타입은 달라야 한다.
    - 사용 이유 : 이름이 같은 여러 개의 메소드를 선언하려고(편리성)




- 오버라이딩(@Override) *** 어노테이션 사용해줘야 함
    - 개념 :  자식클래스(서브클래스)에서 부모클래스(슈퍼클래스)에 있는 메소드를 재정의
    - 조건 : 메소드 이름은 동일해야 함. 파라미터(인수, 인자, 매개변수) 개수, 타입도 같아야 한다.
    - 사용 이유 : 부모클래스 메소드 무시하고 자식클래스에서 재정의하려고.


        *  오버라이딩을 정말 많이 사용한다.

        오버로딩은 파라미터 개수와 타입이 서로 달라야 하고 
        오버라이딩은 파라미터 개수와 타입이 같아야 한다.




### 오버라이딩 문제
``` java
package 상속2;
class Manager{

	public Manager(){ // 디폴트 생성자
	system.out.println("Hello world");

	}

	public int 급여를주다(int 월급){
		return 월급;
	}
	public String 요리를하다(String 식자재){
		return 식자재;
	}
}
class Chef extends Manager{

	public Chef(){
		super(); // super라는 메소드가 디폴트로 생성
		// super는 부모클래스의 생성자를 의미함.
	}

	@Override
	public int 급여를주다(int 월급){
		return 월급*3; // 오버라이딩을 해줬기 때문에 manager클래스의 급여 메소드는 삭제됨 => 1개
	}
	public String 요리를하다(String 식자재){
		return 식자재; // 세프와 매니저 클래스의 메소드가 동일해서 자식에 있는 메소드 1개만 인식이 됨. => 2개
	}
	public String 요리를하다(String 식자재, String 비밀소스){
		return 식자재+비밀소스; // 오버로딩으로 사용 가능한 메소드가 됨 => 3개
	}

}
public class Restaurant {
	public static void main(String[] args) {
		Chef chef = new Chef();
	}
}

```

- Q. Chef 호출시 사용할 수 있는 메소드 개수는? 
- A. 3개




####
```java

package 상속2;


class Study extends Object{ //  중복 제거하기
	public void doSleep(String subjects) {
		System.out.println("꿀잠자다");
	}
	
	
	public void doStudy(String subjects) {
		System.out.println(subjects + "공부를하다");
	}
	
}

class StudentC extends Study{ // Study클래스를 상속 extends 기준으로 왼쪽(자식) 오른쪽(부모)
	
	@Override
	public void doSleep(String subjects) {
		System.out.println("공부중"); //  위 Study클래스의 doSleep 메소드는 오버라이딩으로 무시됨
	} 
	
	public void doStudy(int x) {
		
	}
	
	public void doStudy(int x, int y) {
	}
	
	public void doStudy(String subjects) {
		System.out.println("공부하기 실허요");
	}
}

class StudentB{
	
	public void doStudy() {
	}
}

class StudentA{
	public void doStudy() {
	}
	
}

public class School {
	
	public static void main(String[] args) {
//		
		//방법2
//		 new StudentA().doStudy(); 
//		 new StudentB().doStudy(); 
//		 new StudentC().doStudy(); 
		 //문제점 : 같은 기능을 하는 메소드가 중복됨
		 //해결책 : 상속을 이용해서 중복된 코드(메소드)를 제거!
		 
		StudentC s = new StudentC();
		s.doSleep("");
	
	}
}
