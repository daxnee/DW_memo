접근 지정자

 - public, private, protected, default public

   UMLUnified Modeling Language)? : 통합 모델링 언어.
    즉, 모델을 만드는 표준 언어다

    - : 접근지정자가 private 
    + : 접근지정자가 public 


### 생성자 vs 일반함수(메소드) 차이점
- 생성자 : 리턴타입이 없는 함수(메소드)
	- 생성자는 return 타입을 정의하지 않아도 된다.

		- why? 생성자는 값을 초기화하는 것이 목적이라서 함수에 파라미터의 값을 받아서 결과를 처리하는게 목적임!

- 생성자 특징
1) 초기화
2) 생성자 이름이 클래스 이름과 동일해야 함 (이름이 다르면 다른 함수로 인식해서 return타입을 요구함. 에러발생)

- 함수 특징
1) 로직을 처리 or 리턴

### 필드변수의 특징
초기화가 디폴트
null or 0 
초기화 할 필요가 없다.



### 생성자 특징
 1. 생성자 이름은 클래스 이름과 동일
    1. 생성자는 함수다(특수 함수)
    2. 리턴이 없음(void도 없음)
    3. 함수이름은 클래스이름과 동일
    4. 기본 생성자(디폴트 생성자) 존재
        (기본 생성자를 사용하고 싶으면 디폴트값을 입력하고 
        그 후에 파라미터 값을 입력해야함)
    5. 생성자를 사용하는 이유?
        => 필드 변수에 값을 대입하기 위해서

	- tip! 생성자의 개수가 많아지면 코드가 길어지니
파라미터값으로 바로 넣어줘서 간결한 코드를 만들수도 있다.


### get, set 
- get이 붙으면 return 타입이 없는 메소드다. 내가 원하는 것만 set을 할 수 있다.

### 오버로딩 
-  메소드 이름은 동일, 파라미터값(인자값)은 달라야 한다.
객체지향 프로그래밍에서 오버로딩은 존재한다


### 데이터 타입
- 정적타입 
: int, double,  char

- 동적타입
: String, 클래스, 배열(동적, 정적 모두 가능)
Heap area (Heap 이라는 공간(영역)에 저장) *Heap : 메모리

heap error : 호출한 클래스가 많아서 생기는 에러. 클래스가 많아서 저장하는 공간이 부족해지는 것을 말함.

 즉, 정적과 동적은 메모리를 저장하는 공간이 다르다.


 ### 상속
1. 상속 클래스를 만드는 이유?
: 여러 기능을 하는 메소드를 일일히 만들지 않고 
한군데에 만들어서 필요할 때마다 가져다 쓰기 위해 존재함.
=> 공통기능 class를 만들어서 필요한 클래스에서 호출하며 사용하는 것.


- 부모 클래스 or 슈퍼 클래스 : 메소드, 필드변수를 제공하는 주체

### 상속자 특징 :  
1. 자식 클래스는 부모 클래스의 필드변수와 메소드를 사용할 수 있지만, 그 반대는 사용할 수 없다. (부모는 자식x)
2. 모든 클래스의 부모는 object다. (무조건 부모가 있어야 한다. 디폴트) 클래스를 생성하면 보이지 않지만 object를 상속해주고 있다.
3. 자바는 C++과 다르게 다중 상속이 없다. (부모가 한명)


### 왜 메소드를 만들까? 

why? : 실무에선 보안때문에 필드변수를 private으로 막아놓음. 그래서 메소드를 이용해서 데이터를 조작해야 됨
★Keypoint : 필드변수는 메소드를 활용해서 접근해야 한다.


## 컬렉션즈 (컬렉션즈 프레임워크)
---
- 컬렉션도 배열이다.  but 배열과 다르게 길이를 유동적으로 컨트롤 할 수 있음***
- 컬렉션즈 : 프레임워크. 다른 말로는 컨테이너라고 부름. 즉 '값을 담는 그릇'이라는 의미
	- 그런데, 그 값의 성격에 따라 컨테이너의 성격이 조금씩 달라짐.
자바에선 여러 상황에서 사용할 수 있는 다양한 컨테이너를 제공하는데 이것을 컬렉션즈 프레임워크라고 부른다.


 <> : 제네릭
- 제네릭 <> 안에 지정된 데이터 타입에 의해서 ArrayList가 결정된다.
	- <> 안에는 클래스만 올 수 있음.
	
- int -> Integer
- String (String은 클래스라서 대문자로 시작)
- double -> Double


### 상속
- 사용 이유
: 기능이 같은 메소드의 중복을 방지. 슈퍼클래스에서 메소드를 설정해주면 서브클래스에서 상속을 받아 사용한다.
속도, 메모리 공간의 문제를 해결할 수 있음

- 장점
1. 코드 중복 감소
2. 유지 보수 용이(부모 클래스만 수정하면 됨)
3. 자식 클래스 설계시 중복 메소드를 부모 클래스에 작성하면 
자식 클래스에선 해당 메소드를 설정하지 않아도 된다. 


### Static (스태틱)
static 목적 : 공유 (share)
** static으로 선언된 메소드와 변수는 인스턴스화(new)를 하지 않아도 호출이 가능하다.



### 변수 종류는 크게 두가지로 나눈다
 static / non-static

 
### 스태틱 왜 쓰는가? 
여러 클래스에서 사용하면 heap 영역에 new로 생성한 코드들이 넘쳐난다
용량 과부하 그래서 스태틱으로 변수와 메소드를 지정해줘서 호출해서 사용한다.

### static을 사용하는 경우 

1. *** 코드를 정의할 때
    단, 해당 클래스에는 변수만 존재!

2. 객체(클래스)를 여러개 생성해서 사용하는 상황일 때
    ex) 데이터베이스 연동할 때

=> 싱글톤 패턴이 무엇인지만 알고 있으면 된다. 사람들이 이미 만들어 놨기 때문에 만들지 않아도 된다.